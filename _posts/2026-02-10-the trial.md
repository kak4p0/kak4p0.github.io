---
title: "LA CTF 2026 | the-trial"
date: 2026-02-10 01:00:00 +0900
categories: ["LA CTF 2026/Web"]
tags: [Web]
toc: true
comments: false
---

## TL;DR
프론트(UI)가 생성하는 4글자 `word`를 믿을 필요 없이, 서버 엔드포인트 `/getflag`가 **어떤 입력에 플래그를 반환하는지** 확인하면 된다.  
JS에서 요청 형식이 그대로 노출되어 있어 UI를 우회해 직접 POST로 테스트 가능했고, `word=flag`에서 플래그가 반환되었다.

---

## Overview
페이지는 슬라이더 값으로 4글자 문자열 `word`를 만들고 이를 `POST /getflag`로 전송한다.  
핵심은 “프론트가 만드는 값”이 아니라 “서버(`/getflag`)가 플래그를 반환하는 조건”을 찾는 것이다.

- Endpoint: `POST /getflag`
- Content-Type: `application/x-www-form-urlencoded`
- Body: `word=<...>` 형태

---

## Solution

### 1) Recon
목표: 서버 요청 형식과 파라미터 확인
- 브라우저 개발자 도구에서 프론트 JS/네트워크 요청을 확인하면 `/getflag` 로 다음 형태의 요청을 보냄:
  - `fetch("/getflag", { method:"POST", body:"word=..." })`

- 즉, UI를 거치지 않고 동일한 형식으로 직접 요청을 만들 수 있다.

### 2) Root Cause
근본 원인 : 서버가 클라이언트(UI)가 만들어낸 값만 들어올 것이라는 전제에 기대거나, `word` 검증이 약함.
- UI의 “4글자 제한”은 보안 제약이 아니라 단순 UX 제약.
- 공격자는 요청 본문(`word=`)을 마음대로 조작 가능.
- 서버가 특정 입력(예: `"flag"`)에 대해 플래그를 반환하도록 구현되어 있어 우회가 성립.

### 3) Exploit
**UI 우회 후 직접 POST로 `word` 값을 테스트**

```bash
curl -s -X POST 'https://the-trial.chall.lac.tf/getflag' \
  -H 'Content-Type: application/x-www-form-urlencoded' \
  --data 'word=flag'
```

---

### 4) Why it works
- 클라이언트는 신뢰할 수 없고(임의 수정/재현 가능),
- 프론트 JS에 요청 포맷이 노출되어 있으며,
- 서버가 `word=flag` 같은 값에 대해 플래그를 반환하도록 되어 있어,
- UI에서 강제하려던 제한을 무시하고 그대로 플래그를 획득할 수 있다.

---

## Solver
이 문제는 별도 스크립트 없이 curl 한 줄로 재현 가능하다.

```bash
curl -s -X POST 'https://the-trial.chall.lac.tf/getflag' \
  -H 'Content-Type: application/x-www-form-urlencoded' \
  --data 'word=flag'
```

### Result
서버는 `word=flag` 입력에 대해 플래그를 반환했다.
- flag: `lactf{gregor_samsa_awoke_from_wait_thats_the_wrong_book}`
