---
title: "[Forensics] painter"
description: Writeup for "painter" from EHAX CTF 2026.
date: 2026-03-01 09:00:00 +0900
categories: [CTF, EHAX CTF 2026]
tags: [Forensics]
toc: true
comments: false
---

# painter (EHAX CTF 2026)

---

- **Name:** painter
- **Category:** Forensics
- **Description:** there was a painter working for a security company who attempted to deceive one of the employees. To do so, he said flag format EH4X{hihihihi} author - stapat
- **Difficulty:** ★★☆☆☆

---

## TL;DR

The provided `pref.pcap` is **not normal network traffic**.  
It contains **USB mouse (HID) input logs**. By decoding mouse `dx/dy` movements and drawing the path while a mouse button is pressed, we can **reconstruct the text** the attacker “painted”. The text says “what colour is the flag”, and the expected leetspeak flag is:

`EH4X{wh4t_c0l0ur_15_th3_fl4g}`

---

## Overview

This is a “**USB HID forensic**” challenge:

- The PCAP stores USB packets (Linux `usbmon` style).
- Each USB packet contains a small HID report with:
  - mouse buttons (left / right)
  - relative movement (`dx`, `dy`)
- If we **accumulate** `dx/dy` over time, we get the cursor path.
- If we **only draw when a button is pressed**, the cursor path becomes readable text.

The story (“a painter tried to deceive an employee”) is a hint that the attacker **drew** the message using the mouse.

---

## Solution

### 1) Recon

**Goal:** Understand what is inside `pref.pcap`.

In Wireshark:

- The capture is **PCAPNG** and it contains **USB traffic** (not TCP/UDP).
- You will see packets like `USB URB_INTERRUPT in` (endpoint often `0x81`).
- Packet data length is small and constant (commonly **7 bytes**) → typical HID mouse report size.

**Quick CLI checks (WSL Ubuntu):**

```bash
file pref.pcap
# likely: pcapng capture file ...

tshark -r pref.pcap | head
# you should see USB-related lines
```

At this point we suspect: **mouse HID reports**.

---

### 2) Root cause

**Root cause:** The PCAP contains leaked **USB mouse input**.  
Mouse input is enough to rebuild what the user drew on screen.

A common HID mouse report layout is:

- `report_id` (1 byte)
- `buttons` (1 byte)
- `dx` (2 bytes, signed little-endian)
- `dy` (2 bytes, signed little-endian)
- `wheel` (1 byte, signed)

So total: **7 bytes**.

This challenge uses that exact structure.

---

### 3) Exploit (Reconstruction)

**Exploit idea:** Convert mouse packets → coordinates → draw lines.

Steps:

1. Extract the 7-byte HID payload from each USB packet.
2. Parse `buttons`, `dx`, `dy`.
3. Accumulate coordinates:
   - `x += dx`
   - `y += dy`
4. Draw a line from previous point to current point **only if** `buttons != 0`.
5. Save as an image and read the message.

From the reconstructed image, the drawn message reads like:

- `what colou`
- `r i5 th3 fla9`

Interpreting it as a sentence: **“what colour is the flag”** (leet spelling).

The platform expected the final leetspeak normalization:

- `what` → `wh4t`
- `colour` → `c0l0ur`
- `is` → `15`
- `the` → `th3`
- `flag` → `fl4g`

So the correct submission is:

`EH4X{wh4t_c0l0ur_15_th3_fl4g}`

---

### 4) Why it works

USB HID mice report **relative movement** (`dx`, `dy`) at high frequency.

Even without screenshots or keystrokes:

- The cursor path is enough to reconstruct drawings.
- Buttons tell us when the user is “drawing” (mouse-down) vs “moving” (mouse-up).
- Rendering only mouse-down segments makes the text visible.

That is why “USB input capture” is sensitive: it can leak actions and drawings.

---

## Solver

Below is a simple Python solver that:

- parses PCAPNG blocks,
- extracts usbmon payload,
- decodes the 7-byte HID report,
- draws the path to an output image.

### Requirements

```bash
python3 -m pip install pillow numpy
```

### `solve.py`

```python
import io
import struct
import numpy as np
from PIL import Image, ImageDraw, ImageOps

PCAP = "pref.pcap"

def parse_pcapng(buf: bytes):
    f = io.BytesIO(buf)
    while True:
        hdr = f.read(8)
        if len(hdr) < 8:
            return
        btype, blen = struct.unpack("<II", hdr)
        body = f.read(blen - 12)
        _ = f.read(4)  # trailing length
        if len(body) != blen - 12:
            return
        yield btype, body

def parse_epb(body: bytes) -> bytes:
    # Enhanced Packet Block
    iface_id, ts_high, ts_low, cap_len, pkt_len = struct.unpack("<IIIII", body[:20])
    pkt = body[20:20 + cap_len]
    return pkt

def decode_usbmon_hid(pkt: bytes):
    # usbmon header is 64 bytes in this capture
    if len(pkt) < 64:
        return None

    data_len = struct.unpack("<I", pkt[36:40])[0]
    payload = pkt[64:64 + data_len]

    # We expect 7-byte HID mouse report
    if len(payload) != 7:
        return None

    report_id = payload[0]
    buttons = payload[1]
    dx = struct.unpack("<h", payload[2:4])[0]
    dy = struct.unpack("<h", payload[4:6])[0]
    wheel = struct.unpack("b", payload[6:7])[0]
    return report_id, buttons, dx, dy, wheel

def draw(points, out_path, line_w=2):
    xs = np.array([p[0] for p in points], dtype=int)
    ys = np.array([p[1] for p in points], dtype=int)
    btns = np.array([p[2] for p in points], dtype=int)

    minx, maxx = xs.min(), xs.max()
    miny, maxy = ys.min(), ys.max()

    w = maxx - minx + 1
    h = maxy - miny + 1

    img = Image.new("L", (w, h), 255)
    d = ImageDraw.Draw(img)

    sx = xs - minx
    sy = ys - miny

    prev = None
    prev_draw = False

    for x, y, b in zip(sx, sy, btns):
        draw_now = (b != 0)
        if draw_now:
            if prev is not None and prev_draw:
                d.line([prev, (x, y)], fill=0, width=line_w)
            else:
                d.ellipse([x-1, y-1, x+1, y+1], fill=0)
        prev = (x, y)
        prev_draw = draw_now

    # Optional: improve readability
    img = ImageOps.autocontrast(img, cutoff=1)
    img.save(out_path)

def main():
    buf = open(PCAP, "rb").read()

    x = 0
    y = 0
    points = []

    # EPB block type = 0x00000006
    for btype, body in parse_pcapng(buf):
        if btype != 0x00000006:
            continue
        pkt = parse_epb(body)
        dec = decode_usbmon_hid(pkt)
        if not dec:
            continue
        _, buttons, dx, dy, _ = dec
        x += dx
        y += dy
        points.append((x, y, buttons))

    draw(points, "reconstructed.png")
    print("[+] saved: reconstructed.png")
    print("[+] read the message and submit the flag in EH4X{...} format")

if __name__ == "__main__":
    main()
```

### Run

```bash
python3 solve.py
```

Open `reconstructed.png` and read the painted text.

---

## Flag

```
EH4X{wh4t_c0l0ur_15_th3_fl4g}
```
<img width="7440" height="9136" alt="combo_readable_black" src="https://github.com/user-attachments/assets/fbb607f3-0ae1-41ce-9bd1-ec2a38171b97" />
<img width="8336" height="2380" alt="all_crop_readable_black" src="https://github.com/user-attachments/assets/f801b70c-db04-432e-b409-22055afc8a60" />
---

